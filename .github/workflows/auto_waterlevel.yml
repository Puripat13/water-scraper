name: Auto Scrape WaterLevel

on:
  schedule:
    # รันทุกวันเวลา 20:00 ไทย (UTC+7) = 13:00 UTC
    - cron: '0 13 * * *'
  workflow_dispatch:

jobs:
  run-scraper:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    env:
      PYTHONUNBUFFERED: "1"
      CSV_OUT: waterlevel_report.csv

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'

      # ใช้ Chrome แบบพร้อม Selenium Manager (ไม่ต้องลง chromedriver แยก)
      - name: Setup Google Chrome
        uses: browser-actions/setup-chrome@v1
      - name: Show Chrome version
        run: google-chrome --version || true

      - name: Install Python packages
        run: |
          python -m pip install --upgrade pip
          pip install selenium pandas google-api-python-client google-auth google-auth-httplib2

      # scrap2.py ของคุณต้องบันทึก CSV ด้วย 9 คอลัมน์อังกฤษ:
      # Station,Location,Time,Water_Level,Bank_Level,Gauge_Zero,Capacity_Percent,Status,Data_Time
      - name: Run scraper
        run: |
          set -eux
          python scrap2.py
          test -f "${CSV_OUT}"

      - name: Upload artifact (CSV)
        if: always() && hashFiles(env.CSV_OUT) != ''
        uses: actions/upload-artifact@v4
        with:
          name: waterlevel_report
          path: ${{ env.CSV_OUT }}
          if-no-files-found: ignore
          retention-days: 7

      # อัปโหลดขึ้น Google Drive:
      # - ถ้ามี DRIVE_FILE_ID -> "เขียนทับทั้งไฟล์" (เหมาะกับ My Drive)
      # - ถ้าไม่มีแต่มี PURIPAT_ID (โฟลเดอร์ Shared Drive) -> "สร้างใหม่"
      - name: Upload to Google Drive (overwrite by ID or create in folder)
        if: success() && hashFiles(env.CSV_OUT) != ''
        env:
          SERVICE_ACCOUNT_JSON: ${{ secrets.SERVICE_ACCOUNT }}  # เนื้อหา JSON ของ Service Account (ทั้งก้อน)
          DRIVE_FILE_ID: ${{ secrets.DRIVE_FILE_ID }}           # (แนะนำเมื่อใช้ My Drive) fileId ของ waterlevel_report.csv
          DRIVE_FOLDER_ID: ${{ secrets.PURIPAT_ID }}            # (ทางเลือก) โฟลเดอร์ปลายทางใน Shared Drive
          CSV_OUT: ${{ env.CSV_OUT }}
        run: |
          python - <<'PY'
          import os, json
          from google.oauth2.service_account import Credentials
          from googleapiclient.discovery import build
          from googleapiclient.http import MediaFileUpload
          from googleapiclient.errors import HttpError

          SA = json.loads(os.environ["SERVICE_ACCOUNT_JSON"])
          FILE_ID = (os.environ.get("DRIVE_FILE_ID") or "").strip() or None
          FOLDER_ID = (os.environ.get("DRIVE_FOLDER_ID") or "").strip() or None
          CSV = os.environ["CSV_OUT"]

          creds = Credentials.from_service_account_info(SA, scopes=["https://www.googleapis.com/auth/drive"])
          drive = build("drive", "v3", credentials=creds, cache_discovery=False)

          def overwrite(fid, path):
              media = MediaFileUpload(path, mimetype="text/csv", resumable=True)
              drive.files().update(fileId=fid, media_body=media, supportsAllDrives=True).execute()
              print(f"✅ Overwritten Drive fileId={fid}")

          def create(folder_id, path):
              meta = {"name": os.path.basename(path)}
              if folder_id: meta["parents"] = [folder_id]
              media = MediaFileUpload(path, mimetype="text/csv", resumable=True)
              created = drive.files().create(body=meta, media_body=media, fields="id", supportsAllDrives=True).execute()
              print(f"✅ Created new fileId={created['id']}")
              return created["id"]

          try:
              if FILE_ID:
                  # เขียนทับไฟล์เดิม (เหมาะกับ My Drive—ให้เจ้าของไฟล์เป็นคุณ)
                  drive.files().get(fileId=FILE_ID, fields="id", supportsAllDrives=True).execute()
                  overwrite(FILE_ID, CSV)
              elif FOLDER_ID:
                  # สร้างใหม่ใน Shared Drive
                  create(FOLDER_ID, CSV)
              else:
                  raise SystemExit("❌ ต้องใส่อย่างน้อย DRIVE_FILE_ID (My Drive) หรือ DRIVE_FOLDER_ID (Shared Drive)")
          except HttpError as e:
              # เคสสร้างใน My Drive ด้วย SA จะเจอ 403 quota — แจ้งชัดเจน
              if e.resp.status == 403:
                  print("❌ 403: Service Account ไม่มีโควตาใน My Drive — ให้ใช้ DRIVE_FILE_ID (อัปเดตทับไฟล์ที่คุณสร้างไว้) หรืออัปโหลดไป Shared Drive ผ่าน DRIVE_FOLDER_ID")
                  raise
              raise
          PY
